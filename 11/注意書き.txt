8番まで終わらせましたが、公開は来週あたりにしようと思います。
第11回、全体的に見ると若干難しいように思えました。
今のところ一人しかこのrepositoryを教えていませんが、むやみに公開してネット検索に長けた変態に見つかるといやだし、
それがあるとその変態と成績に差がつかないというのも癪なので。
心の狭い人ですみません。
一応ヒントを書こうと思います。
意外とネックなのが1～4番で、二分木に対して再帰的手続きがめちゃくちゃ有効という事実と、そのやり方をわかっていないと案外難しいと思います。
pdfにはwhileでも～みたいなこと書いてありましたが、1～4番、全て再帰です。
whileでも出来るのかは知らないけど再帰のほうが圧倒的にコードがコンパクト＆わかりやすいと思います。
葉を基底にして左の部分木、右の部分木と定義していく感じです。
5,6番はpdfに書いてあることをしっかり書き起こせば問題なく動きます(6番は結構量が多い)。
一番問題なのは7番です。以下が7番での重要な考え方です。

・t->leftをそれまでの問題のNULLのように扱う。 
・ただしNULLと同等というわけではない。要するに空の二分探索木を特別扱いしなくていい。

まぁ特別扱いしなくていい恩恵というのは、正直あまり感じられないですけど。

8番は前に配列の探索でやったのと同じように、自分で設定した番兵に戻ってきてしまってたらNot found.という考え方でやれば大丈夫です。
葉(ダミーノード)と番兵(頭)はポインタが同じアドレスを指しているので、この考え方が実現できます。
pdfに書いてありますが、くれぐれもwhile文中およびその条件にダミーかどうか調べる処理は入れないこと。
whileループしてから、調べる。
