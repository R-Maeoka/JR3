8番まで終わらせましたが、公開は来週あたりにしようと思います。
第11回、全体的に見ると若干難しいように思えました。
今のところ一人しかこのrepositoryを教えていませんが、むやみに公開してネット検索に長けた変態に見つかるといやだし、
それがあるとその変態と成績に差がつかないというのも癪なので。
心の狭い人ですみません。
一応ヒントを書こうと思います。
意外とネックなのが1～4番で、二分木に対して再帰的手続きがめちゃくちゃ有効という事実と、そのやり方をわかっていないと案外難しいと思います(特に2番)。
pdfにはwhileでも～みたいなこと書いてありましたが、1～4番、全て再帰です。
whileでも出来るのかは知らないけど再帰のほうが圧倒的にコードがコンパクト＆わかりやすいと思います。
葉を基底にして左の部分木、右の部分木と定義していく感じです。
5,6番はpdfに書いてあることをしっかり書き起こせば問題なく動きます(6番は結構量が多い)。
一番問題なのは7番です。以下が7番での重要な考え方です。

・t->leftをそれまでの問題のNULLのように扱う。 
・ただしNULLと同等というわけではない。要するに空の二分探索木を特別扱いしなくていい。

まぁ特別扱いしなくていい恩恵というのは、正直あまり感じられないですけど。

8番は前に配列の探索でやったのと同じように、自分で設定した番兵に戻ってきてしまってたらNot found.という考え方でやれば大丈夫です。
葉(ダミーノード)と番兵(頭)はポインタが同じアドレスを指しているので、この考え方が実現できます。
pdfに書いてありますが、くれぐれもwhile文中およびその条件にダミーかどうか調べる処理は入れないこと。
whileループしてから、調べる。

追記。
6番は少しpdfに書かれていないことを考慮しなければだめでした。
削除や挿入の操作において、削除対象や、挿入場所のリンク元を辿らなければなりませんが、
削除命令として、目的の二分探索木の根が指定された場合、頭付きではないので、そのリンク元が辿れません。
よって根を削除する場合、渡された't'そのものに代入するような命令をしないといけません。
そのような命令をしなくても出来るかは知りません。頭付きなら出来ると思いますが、
提出するプログラムの形式がそれに沿っていないのでダメかと思います。

明日(12/20)にチェッカーを通して、6番にしろ、他の問題にしろ、通らなかったら修正した後、またここにヒント書きます。
