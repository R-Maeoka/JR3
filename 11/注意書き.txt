8番まで終わらせましたが、公開は来週あたりにしようと思います。
第11回、全体的に見ると若干難しいように思えました。
今のところ一人しかこのrepositoryを教えていませんが、むやみに公開してネット検索に長けた変態に見つかるといやだし、
それがあるとその変態と成績に差がつかないというのも癪なので。
心の狭い人ですみません。
一応ヒントを書こうと思います。
意外とネックなのが1～4番で、二分木に対して再帰的手続きがめちゃくちゃ有効という事実と、そのやり方をわかっていないと案外難しいと思います(特に2番)。
pdfにはwhileでも～みたいなこと書いてありましたが、1～4番、全て再帰です。
whileでも出来るのかは知らないけど再帰のほうが圧倒的にコードがコンパクト＆わかりやすいと思います。
葉を基底にして左の部分木、右の部分木と定義していく感じです。
5,6番はpdfに書いてあることをしっかり書き起こせば問題なく動きます(6番は結構量が多い)。
一番問題なのは7番です。以下が7番での重要な考え方です。

・t->leftをそれまでの問題のNULLのように扱う。 
・ただしNULLと同等というわけではない。要するに空の二分探索木を特別扱いしなくていい。

まぁ特別扱いしなくていい恩恵というのは、正直あまり感じられないですけど。

8番は前に配列の探索でやったのと同じように、自分で設定した番兵に戻ってきてしまってたらNot found.という考え方でやれば大丈夫です。
葉(ダミーノード)と番兵(頭)はポインタが同じアドレスを指しているので、この考え方が実現できます。
pdfに書いてありますが、くれぐれもwhile文中およびその条件にダミーかどうか調べる処理は入れないこと。
whileループしてから、調べる。

追記。
6番は少しpdfに書かれていないことを考慮しなければだめでした。
削除や挿入の操作において、削除対象や、挿入場所のリンク元を参照しなければポインタのつなぎかえができないので、その操作は行えませんが、
削除命令として、目的の二分探索木の根が指定された場合、頭付きではないので、そのリンク元が参照できません。
よって根を削除する場合、渡された't'そのものに代入するような命令をしないといけません。
そのような命令をしなくても出来るかは知りません。頭付きなら出来ると思いますが、
提出するプログラムの形式がそれに沿っていないのでダメかと思います。

明日(12/20)にチェッカーを通して、6番にしろ、他の問題にしろ、通らなかったら修正した後、またここにヒント書きます。

全てチェッカー通りました。締め切り1月10日なんですね。
こんなに日にちあったらできないほうがおかしいので、授業が終わった今、全部公開します。授業中に提出されたものは加点という言葉を信じて。


思ったんですが、7番のbst_insert関数、頭のidを指定しなければ0で初期化される(多分)わけですが、最初のinsert命令でマイナスの値を入力したら
t->left(ダミーノード)に挿入されてしまって、プログラム全体がおかしなことになってしまいます。おそらくこの問題はidの入力仕様として
5桁の""整数""と言いつつ、5桁の""0以上の整数""を入力してるのでチェッカーも通ってしまったのですが、釈然としないです。解決方法モトム。

自己満足だけど次回からも気づいたことやヒントを書くファイルを設けようと思います。個人的に復習とか内容の理解にもつながるので。
